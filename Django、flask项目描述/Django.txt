1.Django项目中注册时给用户发送激活邮件，使用itsdangerous模块加密，以json方式来编译，加密计算是不能反推的，
采用签名序列化。发送到链接里包含用户id，有效期，创建时间，生成的是bytes类型（二进制）

发送邮件使用celery异步发送
celery的特点是：
简单，易于使用和维护，有丰富的文档。
高效，单个celery进程每分钟可以处理数百万个任务。
灵活，celery中几乎每个部分都可以自定义扩展。
Celery需要一种解决消息的发送和接受的方式，我们把这种用来存储消息的的中间装置叫做message broker, 也可叫做消息中间人（Redis）。


2.模型Model
查询
每个模型类默认都有一个叫 objects 的类属性，它由django自动生成，类型为： django.db.models.manager.Manager，可以把它叫 模型管理器;

objects模型管理器中提供了一些查询数据的方法：

objects管理器中的方法	 	返回类型	作用
模型类.objects.get()		模型对象	返回一个对象，且只能有一个: 如果查到多条数据，则报：MultipleObjectsReturned 如果查询不到数据，则报：DoesNotExist											
模型类.objects.filter()		QuerySet	返回满足条件的对象
模型类.objects.all()		QuerySet	返回所有的对象
模型类.objects.exclude()	QuerySet	返回不满条件的对象
模型类.objects.order_by()	QuerySet	对查询结果集进行排序
模型类.objects.aggregate()	字典，例如：{'salary__avg': 9500.0}     进行聚合操作Sum, Count, Max, Min, Avg
模型类.objects.count()		数字		返回查询集中对象的数目


3.Django自带认证系统（authenticate()函数）
from django.contrib.auth import authenticate,login
	只需要把用户名和密码输入给这个函数自动会与数据库里面用户名和密码进行匹配
使用Django的认证系统记录用户登录状态login（request， user）
注：request用来获取session，user为用户名
	
4.设置session有效期
request.session.set_expiry(None)用来记录用户名，浏览器里面的cookie记录用户session_id,而session_id存储在
服务器里，也就是自带认证系统记录用户登录状态就保存了
登录-> 保存用户的session数据 
只要浏览器中cookie能够在访问的时候带上session_id,
        用户访问其他页面，不需要再次登录
如果cookie中没有session_id，访问的时候后端无法识别用户，要求用户从新登录


5.Django-Redis扩展
Redis用来保存session的数据库，和cache的数据库

为何要用 django-redis ?
因为:
持续更新
本地化的 redis-py URL 符号连接字符串
可扩展客户端
可扩展解析器
可扩展序列器
默认客户端主/从支持
完善的测试
已在一些项目的生产环境中作为 cache 和 session 使用
支持永不超时设置
原生进入 redis 客户端/连接池支持
高可配置 ( 例如仿真缓存的异常行为 )
默认支持 unix 套接字
支持 Python 2.7, 3.4, 3.5 以及 3.6

6.退出
from django.contrib.auth import logout
调用logout（）时，当前请求的会话数据被完全清除，所有存在的数据都将清除

7.验证用户是否登录
使用login_required()装饰器
装饰器加在url路径上面。

8.实现自动跳转页面
# 从查询字符串中尝试获取next的参数
        next = request.GET.get("next")

        if next is None:
            next = reverse("goods:index")

        # 返回,引导进入主页
        return redirect(next)
		
9.保存用户地址信息，自动更新
	address = user.address_set.latest("update_time")
10.用户浏览记录
	用户访问商品详情页时候的记录，存入Redis中，保存sku_id,不放到session数据中，
	是因为方便用户退出再登陆的时候还能查看到数据。
redis中数据库类型 key  value
字符串、列表、哈希、集合、zset
思路1： 操作麻烦
将所有用户的历史记录在redis中保存一条  哈希
“history”: {
“user_id_1”: “1,2,3,4,5”,
“user_id_2”: “1,4,5,6,7
}
hget(“history”, “user_id_1”) 取值
“1， 2，3，4，5 ”
思路2：
每个用户维护一条redis记录
“history_user_1”: [“1”, “2”, “3” ]
“history_user_2”: [“4”, “7”,”9”，”10”]
lrange()
lpush  rpush  ltrim

查询： 只在用户的个人信息页面中看到
“key”： 字符串、列表、哈希、set  zset 
用一条记录保存所有人的信息, 维护起来不方便，不采纳
“history”: {“user_1”: “1,2,3,4,5,6”  , “user_2”:  “”}
conn.hget(“history”, “user_1”)

每个用户一条数据，单独维护
“history_1”:  [1,2,2,3,4,4]
conn.lrange(“history_1”,0, 4)
# 查询浏览历史记录, redis
        # 获取django_redis提供的redis连接对象
        redis_conn = get_redis_connection("default")

        # 浏览历史记录在redis中以列表保存
        redis_key = "history_%s" % user.id
        sku_ids_list = redis_conn.lrange(redis_key, 0, 4)
        # sku_ids_list [7, 4, 8, 2 , 3]


11.密码加密方式
md5,sha1,sha256
二张图片以二进制的方式储存经过md5加密后生成唯一的值区别于其他不同图片，这个值叫做文件指纹


12.fastdfs
FastDFS 是用 c 语言编写的一款开源的分布式文件系统。
FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，
并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务

13.tinymce扩展
from tinymce.models import HTMLField富文本编辑器


14.Django自带密码加密（User类）
	Django 内置的User类提供了用户密码的存储、验证、修改等功能，可以很方便你的给用户提供密码服务。
默认的Ddjango使用pbkdf2_sha256方式来存储和管理用的密码，当然是可以自定义的。

Django 通过PASSWORD_HASHERS 设置选择要使用的算法。下面有一个列表，列出了Django 支持的哈希算法类。
列表的第一个元素 (即settings.PASSWORD_HASHERS[0]) 会用于储存密码， 所有其它元素都是用于验证的哈希值，它们可以用于检查现有的密码。
意思是如果你打算使用不同的算法，你需要修改PASSWORD_HASHERS，来将你最喜欢的算法在列表中放在首位。









14.WSGI
在生产环境中使用WSGI作为python web的服务器
WSGI：全拼为Python Web Server Gateway Interface，Python Web服务器网关接口，是Python应用程序或框架和Web服务器之间的一种接口，被广泛接受。WSGI没有官方的实现, 因为WSGI更像一个协议，只要遵照这些协议，WSGI应用(Application)都可以在任何服务器(Server)上运行
项目默认会生成一个wsgi.py文件，确定了settings模块、application对象
application对象：在Python模块中使用application对象与应用服务器交互
settings模块：用于进行项目配置

15.uWSGI
uWSGI实现了WSGI的所有接口，是一个快速、自我修复、开发人员和系统管理员友好的服务器
uWSGI代码完全用C编写，效率高、性能稳定

16.Nginx
使用nginx的作用主要包括负载均衡、反向代理
所有的静态文件都会由nginx处理，不会将请求转到uwsgi


17.使用缓存
将处理计算的结果先临时保存起来，下次使用的时候可以先直接使用，如果没有这个备份的数据，重新进行计算处理
将缓存数据保存在内容中 （本项目中保存在redis中）
cache
pickle模块  序列化  python标准模块
pickle模块可以将python中的数据类型转换为字符串
pickle.dumps(要转换的数据)  -> 返回之后的字符串
pickle.loads(字符串) -> python的数据 

修改了数据库的数据，直接删除缓存
缓存要设置有效期














