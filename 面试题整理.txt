1.Python中的元类(metaclass)
而在python中，类也是对象，这样的对象就是通过元类来创建的。元类就是"类的类"。
上文中提到的type事实上就是一个元类，在python中，所有的类都是使用type创建的。

2.Python中单下划线和双下划线
	__foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.

	_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.

	__foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.

3.迭代器和生成器
在Python中，这种一边循环一边计算的机制，称为生成器：generator。
生成器是这样一个函数，它记住上一次返回时在函数体中的位置。
对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。
生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。

凡是可作用于 for 循环的对象都是可迭代对象（Iterable） 类型；
凡是可作用于 next() 函数的对象都是迭代器 （Iterator） 类型
集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象。

生成器：
生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。
生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。

生成器的特点：
节约内存
迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，
在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的

4.面向切面编程AOP和装饰器
	这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…

	装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。
	装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。
	概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
	
5.新式类和旧式类
	简单的说，新式类是在创建的时候继承内置object对象（或者是从内置类型，如list,dict等），而经典类是直
接声明的。使用dir()方法也可以看出新式类中定义很多新的属性和方法，而经典类好像就2个

6.__new__和__init__的区别
	__new__是一个静态方法,而__init__是一个实例方法.
	__new__方法会返回一个创建的实例,而__init__什么都不返回.
	只有在__new__返回一个cls的实例时后面的__init__才能被调用.
	当创建一个新实例时调用__new__,初始化一个实例时用__init__.
	
7.单例模式
	1 使用__new__方法
	class Singleton(object):
		def __new__(cls, *args, **kw):
			if not hasattr(cls, '_instance'):
				orig = super(Singleton, cls)
				cls._instance = orig.__new__(cls, *args, **kw)
			return cls._instance

	class MyClass(Singleton):
		a = 1
		
		
	2 import方法
	作为python的模块是天然的单例模式
	# mysingleton.py
	class My_Singleton(object):
		def foo(self):
			pass

	my_singleton = My_Singleton()

	# to use
	from mysingleton import my_singleton

	my_singleton.foo()


8.Python中的作用域
	Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。

	当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：

	本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）
	
9.协程
简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.

10.闭包
闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。
当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:
必须有一个内嵌函数
内嵌函数必须引用外部函数中的变量
外部函数的返回值必须是内嵌函数
1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成
2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存


11.Python里的拷贝
浅拷贝是对于一个对象的顶层拷贝
通俗的理解是：拷贝了引用，并没有拷贝内容
深拷贝是对于一个对象所有层次的拷贝(递归)

@property成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用
将方法转换为只读
重新实现一个属性的设置和读取方法,可做边界判定

12.Python垃圾回收机制
Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。
在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，
通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
	引用计数、标记-清除机制、分代技术

13.read,readline和readlines
	read 读取整个文件
	readline 读取下一行,使用生成器方法
	readlines 读取整个文件到一个迭代器以供我们遍历

14.Python2和3的区别
print() 是函数，不再是⼀个语句
Python2中的raw_input()输⼊函数，改为 input()
Python 3 对⽂本和⼆进制数据做了更为清晰的区分。
1. 文本由unicode表示，为str类型
2. 二进制数据由bytes (字节包)表示，为bytes类型
新增数据类型 bytes (字节包)，代表⼆进制数据以及被编码的⽂本字
符串前有个前缀 b
Python3中字符串类型 bytes 与 str 转换
1. str 可以编码(encode)成 bytes
2. bytes 可以解码(decode)成 str
字符串格式化输出⽅式：新增format()⽅式

15.select,poll和epoll
基本上select有3个缺点:
连接数受限
查找配对速度慢
数据由内核拷贝到用户态
poll改善了第一个缺点
epoll改了三个缺点.

epoll是Linux下多路复用IO接口select/poll的增强版本，
它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，
因为它会复用文件描述符集 合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，
另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符 集，
只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
epoll除了提供select/poll那种IO事件的电平触发 （Level Triggered）外，
还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，
减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
Linux2.6内核中对/dev/epoll设备的访问的封装（system epoll）。

这个使我们开发网络应用程序更加简单，并且更加高效。

16. 死锁
	锁的好处：

	确保了某段关键代码只能由一个线程从头到尾完整地执行
	锁的坏处：

	阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
	由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁
	在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。
	程序设计时要尽量避免（银行家算法）
	添加超时时间等

17.事务
数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。

18.Redis原理

19.乐观锁和悲观锁
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

20.三次握手
客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。
服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。

21.四次挥手

22.ARP协议
地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议

23.urllib和urllib2的区别
urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。
urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。

24.Post和Get

25.Cookie和Session
	          Cookie				Session
储存位置	  客户端				服务器端
目的	跟踪会话，也可以
		保存用户偏好设置或者
		保存用户名密码等			跟踪会话
安全性	      不安全				安全
session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。

26.apache和nginx的区别
nginx 相对 apache 的优点：

轻量级，同样起web 服务，比apache 占用更少的内存及资源
抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，
而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
配置简洁
高度模块化的设计，编写模块相对简单
社区活跃
apache 相对nginx 的优点：

rewrite ，比nginx 的rewrite 强大
模块超多，基本想到的都可以找到
少bug ，nginx 的bug 相对较多
超稳定

27.网站用户密码保存
明文保存
明文hash后保存,如md5
MD5+Salt方式,这个salt可以随机
知乎使用了Bcrypy(好像)加密

28.HTTP和HTTPS
状态码	          定义
1xx 报告	接收到请求，继续进程
2xx 成功	步骤成功接收，被理解，并被接受
3xx 重定向	为了完成请求,必须采取进一步措施
4xx 客户端出错	请求包括错的顺序或不能完成
5xx 服务器出错	服务器无法完成显然有效的请求
403: Forbidden
404: Not Found

HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA

29.XSRF和XSS
CSRF(Cross-site request forgery)跨站请求伪造
XSS(Cross Site Scripting)跨站脚本攻击
CSRF重点在请求,XSS重点在脚本

30.幂等 Idempotence
HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)

31.RESTful架构(SOAP,RPC)

32.SOAP
SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，
使用在计算机网络Web服务（web service）中，交换带结构信息。
SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，
以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

33.CGI和WSGI
CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。
CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。


34.c10k问题
所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。


35. Ajax
AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。


36.装饰器(decorator)功能
引入日志
函数执行时间统计
执行函数前预备处理
执行函数后清理功能
权限校验等场景
缓存
示例：
from time import ctime, sleep

def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__, ctime()))
        func()
    return wrappedfunc

@timefun
def foo():
    print("I am foo")

foo()
sleep(2)
foo()
上面代码理解装饰器执行行为可理解成

foo = timefun(foo)
#foo先作为参数赋值给func后,foo接收指向timefun返回的wrappedfunc
foo()
#调用foo(),即等价调用wrappedfunc()
#内部函数wrappedfunc被引用，所以外部函数的func变量(自由变量)并没有释放
#func里保存的是原foo函数对象


37.面向对象三要素是：封装 继承 多态
 封装就是事物抽象为类，把对外接口暴露，将实现和内部数据隐藏。
 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
 多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
 
38.TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议
TCP通信需要经过创建连接、数据传送、终止连接三个步骤。
TCP特点：1. 面向连接  2. 可靠传输

39.python中解码问题
	1.以什么编码存的就以什么编码取出

	　　内存固定使用unicode编码，

	　　我们可以控制的编码是往硬盘存放或者基于网络传输选择编码。

	2.数据是最先产生于内存中，是unicode格式，要想传输需要转成bytes格式

		#unicode——>encode (utf-8)——–>bytes
	
		拿到bytes，就可以往文件内存存放或者基于网络传输

		#bytes——>decode (utf-8)——–>unicode

	3.python3中字符串被识别成unicode

 		 python3中的字符串encode得到bytes

	4.了解

　　		python2中的字符串就是bytes

　　		python2中的字符串前面加u，就是unicode

	5.任何程序的运行都需要加载到内存中
用通信理论的思路可以理解为:
unicode是信源编码，对字符集数字化;
utf8是信道编码，为更好的存储和传输。
简单来说：Unicode 是「字符集」UTF-8 是「编码规则」其中：字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码……Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节


40.Md5与对称非对称加密的比较区别
	md5是一种不可逆的加密，一定记住是不可逆的虽然现在很多算法也可以将md5解密出来但是md5还是具有很大程度上的不可逆，
而且加大解密难道使用双重加密，很多登录的地方用到md5加密，
那么有些人会问我用md5加密了服务器怎么解密呢，你要是这么想就错了登录时输入用户的密码这个密码被md5加密后在服务器也存的是这个md5的字符格式，
也就是说服务器的数据库存的就是这个格式的字符串，所以服务器那边为什么要解密呢，只要比较你客户端发送的md5字符串和它数据库字符串进行比较就行了。
	还有一种就是可以解密的加密算法，一本分为两种，一种是可以对称的加密算法，
现在大多用的是AES和DES等,因为不管服务端还是客户端都用的是一个相同的密钥所以可以说是对称加密，
比如客户端用这个密钥给一段文字加密服务端收到这段字符串后会用同样的密钥进行解密，另外一种非对称加密用的多的就是RSA，
这个加密之所以叫非对称是因为客户端和服务器用的不是同样的密钥分为公钥和秘钥。打个比方，甲方生成了一对密钥然后把公钥公开提供给乙方也可以是乙1，乙2，乙3...，
然后乙方拿着公钥进行加密，甲方拿着秘钥进行解密，如果记得不错的话支付宝接入就是用的RSA.所以RSA还是用的很普及的，比较适合于一些平台的加密。
